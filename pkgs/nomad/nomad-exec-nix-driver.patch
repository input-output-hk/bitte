diff --git a/client/allocrunner/taskrunner/nix_hook.go b/client/allocrunner/taskrunner/nix_hook.go
new file mode 100644
index 000000000..c06723241
--- /dev/null
+++ b/client/allocrunner/taskrunner/nix_hook.go
@@ -0,0 +1,323 @@
+package taskrunner
+
+import (
+	"context"
+	"fmt"
+	"io"
+	"os"
+	"os/exec"
+	"path/filepath"
+	"strings"
+	"syscall"
+
+	hclog "github.com/hashicorp/go-hclog"
+	log "github.com/hashicorp/go-hclog"
+	"github.com/hashicorp/nomad/client/allocrunner/interfaces"
+	"github.com/hashicorp/nomad/nomad/structs"
+	"github.com/hashicorp/nomad/plugins/drivers"
+)
+
+const (
+	// HookNameNix is the name of the Nix hook
+	HookNameNix = "nix"
+)
+
+// nixHook is used to prepare a task directory structure based on a Nix flake
+type nixHook struct {
+	alloc    *structs.Allocation
+	runner   *TaskRunner
+	logger   log.Logger
+	firstRun bool
+}
+
+func newNixHook(runner *TaskRunner, logger log.Logger) *nixHook {
+	h := &nixHook{
+		alloc:    runner.Alloc(),
+		runner:   runner,
+		firstRun: true,
+	}
+	h.logger = logger.Named(h.Name())
+	return h
+}
+
+func (*nixHook) Name() string {
+	return HookNameNix
+}
+
+func (h *nixHook) emitEvent(event string, message string) {
+	h.runner.EmitEvent(structs.NewTaskEvent(event).SetDisplayMessage(message))
+}
+
+func (h *nixHook) emitEventError(event string, err error) {
+	h.runner.EmitEvent(structs.NewTaskEvent(event).SetFailsTask().SetSetupError(err))
+}
+
+func (h *nixHook) Prestart(ctx context.Context, req *interfaces.TaskPrestartRequest, resp *interfaces.TaskPrestartResponse) error {
+	first := h.firstRun
+	if first {
+		h.firstRun = false
+	} else {
+		return nil
+	}
+
+	configFlakeDeps, flakeDepsSet := req.Task.Config["flake_deps"]
+	configFlake, flakeSet := req.Task.Config["flake"]
+	configFlakeArgs, flakeArgsSet := req.Task.Config["flake_args"]
+	configStorePaths, storePathsSet := req.Task.Config["store_paths"]
+
+	storePaths := []string{}
+	if storePathsSet {
+		for _, sp := range configStorePaths.([]interface{}) {
+			storePaths = append(storePaths, sp.(string))
+		}
+
+		resp.Mounts = append(resp.Mounts, &drivers.MountConfig{
+			TaskPath:        "/nix",
+			HostPath:        "/nix",
+			Readonly:        false,
+			PropagationMode: "host-to-task",
+		})
+
+		return h.buildStorePaths(storePaths)
+	}
+
+	flakes := []string{}
+	if flakeDepsSet {
+		for _, dep := range configFlakeDeps.([]interface{}) {
+			flakes = append(flakes, dep.(string))
+		}
+	}
+
+	if flakeSet {
+		flakes = append(flakes, configFlake.(string))
+	}
+
+	flakeArgs := []string{}
+	if flakeArgsSet {
+		flakeArgs = configFlakeArgs.([]string)
+	}
+
+	if len(flakes) == 0 {
+		return nil
+	}
+
+	return h.install(flakes, flakeArgs, req.TaskDir.Dir)
+}
+
+// store paths are anything buildable really.
+// as well as /nix/store/<hash>-<name> which will be pulled from a substituter
+func (h *nixHook) buildStorePaths(storePaths []string) error {
+	h.logger.Debug("fetching store paths", "paths", storePaths)
+	h.emitEvent("Nix", "fetching store paths: "+strings.Join(storePaths, " "))
+
+	args := append([]string{"-L", "build", "--no-link"}, storePaths...)
+	cmd := exec.Command("nix", args...)
+	return cmd.Run()
+}
+
+// install takes a flake URL like:
+// github:NixOS/nixpkgs#cowsay
+// github:NixOS/nixpkgs?ref=nixpkgs-unstable#cowsay
+// github:NixOS/nixpkgs?rev=04b19784342ac2d32f401b52c38a43a1352cd916#cowsay
+//
+// the given flake
+func (h *nixHook) install(flakes []string, flakeArgs []string, taskDir string) error {
+	linkPath := filepath.Join(taskDir, "current-alloc")
+	_, err := os.Stat(linkPath)
+	if err == nil {
+		return nil
+	}
+
+	h.logger.Debug("Building flakes", "flake", flakes)
+	h.emitEvent("Nix", "building flakes: "+strings.Join(flakes, " "))
+
+	taskDirInfo, err := os.Stat(taskDir)
+	if err != nil {
+		return err
+	}
+
+	uid, gid := getOwner(taskDirInfo)
+
+	for _, flake := range flakes {
+		if err = h.profileInstall(linkPath, flake, flakeArgs); err != nil {
+			return err
+		}
+	}
+
+	requisites, err := h.requisites(linkPath)
+	if err != nil {
+		return err
+	}
+
+	// Now copy each dependency into the allocation /nix/store directory
+	for _, requisit := range requisites {
+		h.logger.Debug("linking", "requisit", requisit)
+
+		err = filepath.Walk(requisit, copyAll(h.logger, taskDir, false, uid, gid))
+		if err != nil {
+			return err
+		}
+	}
+
+	link, err := filepath.EvalSymlinks(linkPath)
+	if err != nil {
+		return err
+	}
+
+	h.logger.Debug("linking main drv paths", "linkPath", linkPath, "link", link)
+
+	return filepath.Walk(link, copyAll(h.logger, taskDir, true, uid, gid))
+}
+
+func (h *nixHook) profileInstall(linkPath string, flake string, flakeArgs []string) error {
+	h.logger.Debug("Building flake", "flake", flake)
+	h.emitEvent("Nix", "building flake: "+flake)
+
+	args := []string{"profile", "install", "--no-write-lock-file", "--profile", linkPath}
+	args = append(append(args, flakeArgs...), flake)
+	cmd := exec.Command("nix", args...)
+	output, err := cmd.CombinedOutput()
+
+	h.logger.Debug(cmd.String(), "output", string(output))
+
+	if err != nil {
+		h.logger.Error(cmd.String(), "output", string(output), "error", err)
+		h.emitEvent("Nix", "build failed with error: "+err.Error()+" output: "+string(output))
+		return err
+	}
+
+	return nil
+}
+
+func (h *nixHook) outPath(flake string, flakeArgs []string) (string, error) {
+	// Then get the path to the derivation output
+	args := []string{"eval", "--raw", "--apply", "(pkg: pkg.outPath)"}
+	args = append(append(args, flakeArgs...), flake)
+	cmd := exec.Command("nix", args...)
+	nixEvalOutput, err := cmd.Output()
+	path := string(nixEvalOutput)
+	h.logger.Debug(cmd.String(), "stdout", path)
+	if err != nil {
+		if ee, ok := err.(*exec.ExitError); ok {
+			h.logger.Error(cmd.String(), "error", err, "stderr", string(ee.Stderr))
+		} else {
+			h.logger.Error(cmd.String(), "error", err, "stdout", path)
+		}
+		return path, err
+	}
+
+	return path, nil
+}
+
+// Collect all store paths required to run it
+func (h *nixHook) requisites(outPath string) ([]string, error) {
+	cmd := exec.Command("nix-store", "--query", "--requisites", outPath)
+	nixStoreOutput, err := cmd.Output()
+
+	if err != nil {
+		if ee, ok := err.(*exec.ExitError); ok {
+			h.logger.Error(cmd.String(), "error", err, "stderr", string(ee.Stderr))
+		} else {
+			h.logger.Error(cmd.String(), "error", err, "stdout", string(nixStoreOutput))
+		}
+		return []string{}, err
+	}
+
+	return strings.Fields(string(nixStoreOutput)), nil
+}
+
+func copyAll(logger hclog.Logger, targetDir string, truncate bool, uid, gid int) filepath.WalkFunc {
+	return func(path string, info os.FileInfo, err error) error {
+		if err != nil {
+			return err
+		}
+
+		var dst string
+		if truncate {
+			parts := splitPath(path)
+			dst = filepath.Join(append([]string{targetDir}, parts[3:]...)...)
+		} else {
+			dst = filepath.Join(targetDir, path)
+		}
+
+		// Skip the file if it already exists at the dst
+		stat, err := os.Stat(dst)
+		lstat, _ := os.Lstat(dst)
+		if err == nil {
+			return nil
+		}
+		if !os.IsNotExist(err) {
+			logger.Debug("stat errors", "err", err, "stat",
+				fmt.Sprintf("%#v", stat),
+			)
+			return err
+		}
+
+		if info.Mode()&os.ModeSymlink != 0 {
+			link, err := os.Readlink(path)
+			if err != nil {
+				return err
+			}
+			// logger.Debug("l", "link", link, "dst", dst)
+			if err := os.Symlink(link, dst); err != nil {
+				if !os.IsExist(err) {
+					logger.Debug("stat", fmt.Sprintf("%#v", stat))
+					logger.Debug("lstat", fmt.Sprintf("%#v", lstat))
+					return err
+				}
+			}
+			if info.IsDir() {
+				return filepath.SkipDir
+			} else {
+				return nil
+			}
+		}
+
+		if info.IsDir() {
+			// logger.Debug("d", "dst", dst)
+			return os.MkdirAll(dst, 0777)
+		}
+
+		// logger.Debug("f", "dst", dst)
+		srcfd, err := os.Open(path)
+		if err != nil {
+			return err
+		}
+		defer srcfd.Close()
+
+		dstfd, err := os.OpenFile(dst, os.O_WRONLY|os.O_CREATE, info.Mode())
+		if err != nil {
+			return err
+		}
+		defer dstfd.Close()
+
+		if _, err = io.Copy(dstfd, srcfd); err != nil {
+			return err
+		}
+
+		if err := dstfd.Chown(uid, gid); err != nil {
+			return fmt.Errorf("Couldn't copy %q to %q: %v", path, dst, err)
+		}
+
+		return nil
+	}
+}
+
+func getOwner(fi os.FileInfo) (int, int) {
+	stat, ok := fi.Sys().(*syscall.Stat_t)
+	if !ok {
+		return -1, -1
+	}
+	return int(stat.Uid), int(stat.Gid)
+}
+
+// SplitPath splits a file path into its directories and filename.
+func splitPath(path string) []string {
+	dir := filepath.Dir(path)
+	base := filepath.Base(path)
+	if dir == "/" {
+		return []string{base}
+	} else {
+		return append(splitPath(dir), base)
+	}
+}
diff --git a/client/allocrunner/taskrunner/task_runner_hooks.go b/client/allocrunner/taskrunner/task_runner_hooks.go
index 089e834d7..0c2ac3504 100644
--- a/client/allocrunner/taskrunner/task_runner_hooks.go
+++ b/client/allocrunner/taskrunner/task_runner_hooks.go
@@ -83,6 +83,8 @@ func (tr *TaskRunner) initHooks() {
 			}))
 	}
 
+	tr.runnerHooks = append(tr.runnerHooks, newNixHook(tr, hookLogger))
+
 	// If Vault is enabled, add the hook
 	if task.Vault != nil {
 		tr.runnerHooks = append(tr.runnerHooks, newVaultHook(&vaultHookConfig{
diff --git a/client/allocrunner/taskrunner/template/template.go b/client/allocrunner/taskrunner/template/template.go
index 8538908cc..36e41e936 100644
--- a/client/allocrunner/taskrunner/template/template.go
+++ b/client/allocrunner/taskrunner/template/template.go
@@ -6,6 +6,7 @@ import (
 	"fmt"
 	"math/rand"
 	"os"
+	"path/filepath"
 	"sort"
 	"strconv"
 	"strings"
@@ -219,6 +220,50 @@ func (tm *TaskTemplateManager) run() {
 	// Block till all the templates have been rendered
 	tm.handleFirstRender()
 
+	// Set o+r for all parent directories for each template inside the task dir.
+	for _, template := range tm.config.Templates {
+		destPath := template.DestPath
+		// TODO properly resolve all possible variables
+		// render path as template? https://github.com/hashicorp/consul-template/issues/974
+		destPath = strings.ReplaceAll(destPath, "${NOMAD_ALLOC_DIR}", "../alloc")
+		destPath = strings.ReplaceAll(destPath, "${NOMAD_TASK_DIR}", "/local")
+		destPath = strings.ReplaceAll(destPath, "${NOMAD_SECRETS_DIR}", "/secrets")
+
+		destDir := destPath
+		for {
+			destDir, _ = filepath.Split(destDir)
+			if destDir == "" {
+				break
+			}
+
+			// strip trailing separator for the next filepath.Split()
+			destDir = destDir[:len(destDir)-1]
+
+			dir := filepath.Join(tm.config.TaskDir, destDir)
+
+			info, err := os.Lstat(dir)
+			if err != nil {
+				tm.config.Lifecycle.Kill(context.Background(),
+					structs.NewTaskEvent(structs.TaskKilling).
+						SetFailsTask().
+						SetDisplayMessage(fmt.Sprintf("Template failed to stat template dir: %v", err)))
+				return
+			}
+
+			perm := info.Mode().Perm()
+			req := os.FileMode(0002) // other write
+			if perm&req != req {
+				if err := os.Chmod(dir, perm|req); err != nil {
+					tm.config.Lifecycle.Kill(context.Background(),
+						structs.NewTaskEvent(structs.TaskKilling).
+							SetFailsTask().
+							SetDisplayMessage(fmt.Sprintf("Template failed changing template dir permissions: %v", err)))
+					return
+				}
+			}
+		}
+	}
+
 	// Detect if there was a shutdown.
 	select {
 	case <-tm.shutdownCh:
diff --git a/drivers/exec/driver.go b/drivers/exec/driver.go
index f035d1568..82a5064bf 100644
--- a/drivers/exec/driver.go
+++ b/drivers/exec/driver.go
@@ -83,12 +83,16 @@ var (
 	// taskConfigSpec is the hcl specification for the driver config section of
 	// a task within a job. It is returned in the TaskConfigSchema RPC
 	taskConfigSpec = hclspec.NewObject(map[string]*hclspec.Spec{
-		"command":  hclspec.NewAttr("command", "string", true),
-		"args":     hclspec.NewAttr("args", "list(string)", false),
-		"pid_mode": hclspec.NewAttr("pid_mode", "string", false),
-		"ipc_mode": hclspec.NewAttr("ipc_mode", "string", false),
-		"cap_add":  hclspec.NewAttr("cap_add", "list(string)", false),
-		"cap_drop": hclspec.NewAttr("cap_drop", "list(string)", false),
+		"command":     hclspec.NewAttr("command", "string", true),
+		"args":        hclspec.NewAttr("args", "list(string)", false),
+		"pid_mode":    hclspec.NewAttr("pid_mode", "string", false),
+		"ipc_mode":    hclspec.NewAttr("ipc_mode", "string", false),
+		"cap_add":     hclspec.NewAttr("cap_add", "list(string)", false),
+		"cap_drop":    hclspec.NewAttr("cap_drop", "list(string)", false),
+		"flake":       hclspec.NewAttr("flake", "string", false),
+		"flake_args":  hclspec.NewAttr("flake_args", "list(string)", false),
+		"flake_deps":  hclspec.NewAttr("flake_deps", "list(string)", false),
+		"store_paths": hclspec.NewAttr("store_paths", "list(string)", false),
 	})
 
 	// driverCapabilities represents the RPC response for what features are
@@ -195,6 +199,11 @@ type TaskConfig struct {
 
 	// CapDrop is a set of linux capabilities to disable.
 	CapDrop []string `codec:"cap_drop"`
+
+	Flake      []string `codec:"flake"`
+	FlakeArgs  []string `codec:"flake_args"`
+	FlakeDeps  []string `codec:"flake_deps"`
+	StorePaths []string `codec:"store_paths"`
 }
 
 func (tc *TaskConfig) validate() error {
diff --git a/flake.lock b/flake.lock
new file mode 100644
index 000000000..40ee5c932
--- /dev/null
+++ b/flake.lock
@@ -0,0 +1,110 @@
+{
+  "nodes": {
+    "lowdown-src": {
+      "flake": false,
+      "locked": {
+        "lastModified": 1598695561,
+        "narHash": "sha256-gyH/5j+h/nWw0W8AcR2WKvNBUsiQ7QuxqSJNXAwV+8E=",
+        "owner": "kristapsdz",
+        "repo": "lowdown",
+        "rev": "1705b4a26fbf065d9574dce47a94e8c7c79e052f",
+        "type": "github"
+      },
+      "original": {
+        "owner": "kristapsdz",
+        "repo": "lowdown",
+        "type": "github"
+      }
+    },
+    "nix": {
+      "inputs": {
+        "lowdown-src": "lowdown-src",
+        "nixpkgs": "nixpkgs",
+        "nixpkgs-regression": "nixpkgs-regression"
+      },
+      "locked": {
+        "lastModified": 1663261928,
+        "narHash": "sha256-oQOuN2oeph4ScDGhPuJdmtuVZOBYitGKYTK5Px7DpxU=",
+        "path": "/nix/store/lzmaymi4czq2kk271ixaxi474jvs422n-source",
+        "rev": "567636cce8a6a55e0933ecebb081a80da2a5bd45",
+        "type": "path"
+      },
+      "original": {
+        "id": "nix",
+        "type": "indirect"
+      }
+    },
+    "nixpkgs": {
+      "locked": {
+        "lastModified": 1670363342,
+        "narHash": "sha256-VCleVeiToASAEb3gcjqVA8MckPAME6y+27QApquGT8k=",
+        "owner": "NixOS",
+        "repo": "nixpkgs",
+        "rev": "d881cf9fd64218a99a64a8bdae1272c3f94daea7",
+        "type": "github"
+      },
+      "original": {
+        "owner": "NixOS",
+        "ref": "nixos-22.05-small",
+        "repo": "nixpkgs",
+        "type": "github"
+      }
+    },
+    "nixpkgs-regression": {
+      "locked": {
+        "lastModified": 1643052045,
+        "narHash": "sha256-uGJ0VXIhWKGXxkeNnq4TvV3CIOkUJ3PAoLZ3HMzNVMw=",
+        "owner": "NixOS",
+        "repo": "nixpkgs",
+        "rev": "215d4d0fd80ca5163643b03a33fde804a29cc1e2",
+        "type": "github"
+      },
+      "original": {
+        "owner": "NixOS",
+        "repo": "nixpkgs",
+        "rev": "215d4d0fd80ca5163643b03a33fde804a29cc1e2",
+        "type": "github"
+      }
+    },
+    "nixpkgs_2": {
+      "locked": {
+        "lastModified": 1670276674,
+        "narHash": "sha256-FqZ7b2RpoHQ/jlG6JPcCNmG/DoUPCIvyaropUDFhF3Q=",
+        "owner": "NixOS",
+        "repo": "nixpkgs",
+        "rev": "52e3e80afff4b16ccb7c52e9f0f5220552f03d04",
+        "type": "github"
+      },
+      "original": {
+        "owner": "NixOS",
+        "ref": "nixos-22.11",
+        "repo": "nixpkgs",
+        "type": "github"
+      }
+    },
+    "root": {
+      "inputs": {
+        "nix": "nix",
+        "nixpkgs": "nixpkgs_2",
+        "utils": "utils"
+      }
+    },
+    "utils": {
+      "locked": {
+        "lastModified": 1601282935,
+        "narHash": "sha256-WQAFV6sGGQxrRs3a+/Yj9xUYvhTpukQJIcMbIi7LCJ4=",
+        "owner": "numtide",
+        "repo": "flake-utils",
+        "rev": "588973065fce51f4763287f0fda87a174d78bf48",
+        "type": "github"
+      },
+      "original": {
+        "owner": "numtide",
+        "repo": "flake-utils",
+        "type": "github"
+      }
+    }
+  },
+  "root": "root",
+  "version": 7
+}
diff --git a/flake.nix b/flake.nix
new file mode 100644
index 000000000..618d64b7c
--- /dev/null
+++ b/flake.nix
@@ -0,0 +1,66 @@
+{
+  description = "Flake for Nomad";
+
+  inputs = {
+    nixpkgs.url = "github:NixOS/nixpkgs/nixos-22.11";
+    utils.url = "github:numtide/flake-utils";
+  };
+
+  outputs = {
+    self,
+    nixpkgs,
+    utils,
+    nix,
+  }: (utils.lib.eachSystem ["x86_64-linux" "x86_64-darwin"] (system: let
+    overlay = final: prev: {
+      go = prev.go_1_19;
+      nomad = final.buildGoModule {
+        pname = "nomad";
+        version = "1.4.3";
+
+        subPackages = ["."];
+
+        src = ./.;
+
+        vendorSha256 = "sha256-JQRpsQhq5r/QcgFwtnptmvnjBEhdCFrXFrTKkJioL3A=";
+
+        # ui:
+        #  Nomad release commits include the compiled version of the UI, but the file
+        #  is only included if we build with the ui tag.
+        # nonvidia:
+        #  We disable Nvidia GPU scheduling on Linux, as it doesn't work there:
+        #  Ref: https://github.com/hashicorp/nomad/issues/5535
+        preBuild = let
+          tags = ["ui"] ++ prev.lib.optional prev.stdenv.isLinux "nonvidia";
+          tagsString = prev.lib.concatStringsSep " " tags;
+        in ''
+          export buildFlagsArray=(
+            -tags="${tagsString}"
+          )
+        '';
+
+        meta = with prev.lib; {
+          homepage = "https://www.nomadproject.io/";
+          description = "A Distributed, Highly Available, Datacenter-Aware Scheduler";
+          platforms = platforms.unix;
+          license = licenses.mpl20;
+          maintainers = with maintainers; [manveru];
+        };
+      };
+    };
+
+    pkgs = import nixpkgs {
+      inherit system;
+      overlays = [overlay];
+    };
+  in {
+    inherit overlay;
+
+    packages = {inherit (pkgs) nomad;};
+    defaultPackage = pkgs.nomad;
+
+    devShell = pkgs.mkShell {
+      buildInputs = with pkgs; [go gotools gopls gocode];
+    };
+  }));
+}
